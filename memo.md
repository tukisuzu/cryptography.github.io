# memo

一斉送信しかできないので、個別に送信するためには、個別に暗号化する必要がある。  

## 画面構成

+ main.html (メイン画面)  
+ main.css (メイン画面のスタイルシート)  
+ main.js (メイン画面のスクリプト)  

## 構成

1. 電子署名用の長期鍵を生成する。  
   認証に用いるデータは、鍵交換に用いるデータを使う。  
2. 両者の電子署名を検証し、秘密鍵の保持を確認する。  
3. 鍵交換により、今回の通信に用いる共有鍵を生成する。  

## 接続

### 接続前準備

+ 電子署名用の長期鍵を生成する。  
  互いに公開鍵を交換しておく。  

### 接続手順

1. A -> B  
   + 送信先を識別するために B の公開鍵を送信する。  
   + 送信元を識別するために A 自身の公開鍵を送信する。  
   + 鍵交換用の鍵ペアを生成する。これはセッション毎に異なる。  
   + 鍵交換用公開鍵を送信する。  
   + 鍵交換用公開鍵の電子署名を送信する。  
2. B -> A  
   + 送信先を識別するために A の公開鍵を送信する。  
   + 送信元を識別するために B 自身の公開鍵を送信する。  
   + 鍵交換用の鍵ペアを生成する。これはセッション毎に異なる。  
   + 鍵交換用公開鍵を送信する。  
   + 鍵交換用公開鍵の電子署名を送信する。  
   + 暗号化された文「Finished」を送信する。  
3. A -> B  
   + B からの「Finished」を受信することで、接続完了とする。  
   + 送信先を識別するために B の公開鍵を送信する。  
   + 送信元を識別するために A 自身の公開鍵を送信する。
   + 暗号化された文「Finished」を送信する。  
4. B  
   + A からの「Finished」を受信することで、接続完了とする。  

アドレスとして長期鍵の公開鍵を用いる。  
<!-- 毎回全文復号して本人かどうかを判定するのは計算量が大きいので、乱数とその暗号文の2つも同時に送信しておき、暗号文を復号して乱数と一致するかどうかを判定してから本文の復号を始める。   -->

## 通信

+ 会話の初めに接続を行う。  
+ 最後の会話から 10 分経過したら接続を切断する。  
+ 同時接続数が一定数を越えたら、古い接続を切断する。ただし、全てのデータが受信されているもののみ。  
+ 各データに連番をつけ、受信の確認を行う。  
+ 送信側で、受信の確認が取れない場合は、再送を行う。  
+ 受信側で、受信したデータの番号に飛びがある場合は、再送を要求する。  
+ 各データは並列に送信できるが、分割されたデータは順番に送信する。  
+ 受信側で、分割されたデータが届かない場合は、再送を要求する。ただし、一定時間待つ。  
+ 再送や再送要求に連続して失敗した場合は、接続を切断する。このとき、送受信していたデータが破損している可能性がある。  

## データ形式

+ type 1  

  ```json
  {
    "type": 1,
    "from": "A の公開鍵",
    "to": "B の公開鍵",
    "key": "鍵交換用の公開鍵",
    "signature": "鍵交換用公開鍵の電子署名",
  }
  ```

+ type 2  

  ```json
  {
    "type": 2,
    "from": "B の公開鍵",
    "to": "A の公開鍵",
    "key": "鍵交換用の公開鍵",
    "signature": "鍵交換用公開鍵の電子署名",
    "finish": "暗号化された文: Finished",
  }
  ```

+ type 3  

  ```json
  {
    "type": 3,
    "from": "A の公開鍵",
    "to": "B の公開鍵",
    "finish": "暗号化された文: Finished",
  }
  ```

+ type 0  

  ```json
  {
    "type": 0,
    "from": "B の公開鍵",
    "to": "A の公開鍵",
    "ciphertext": "暗号文",
  }
  ```

+ 暗号文: 文字列  

  ```json
  {
    "type": "text",
    "data": "文章データ, 1MB 以下",
    "hasNext": "次のデータがあるかどうか",
    "index": "分割されたデータのインデックス",
    "sequence": "データの連番(分割されたものは同一)",
  }
  ```

+ 暗号文: ファイル(1回)  

  ```json
  {
    "type": "file",
    "data": {
      "name": "ファイル名",
      "size": "ファイルサイズ",
      "type": "ファイルタイプ",
      "data": "ファイルデータ",
    },
    "hasNext": "次のデータがあるかどうか",
    "index": "分割されたデータのインデックス",
    "sequence": "データの連番(分割されたものは同一)",
  }
  ```

+ 暗号文: ファイル(複数回) 初回  

  ```json
  {
    "type": "file",
    "data": {
      "name": "ファイル名",
      "size": "ファイルサイズ",
      "type": "ファイルタイプ",
    },
    "hasNext": "次のデータがあるかどうか",
    "index": "分割されたデータのインデックス",
    "sequence": "データの連番(分割されたものは同一)",
  }
  ```

+ 暗号文: ファイル(複数回) 2回目以降  

  ```json
  {
    "type": "file",
    "data": "ファイルデータ, 1MB 以下",
    "hasNext": "次のデータがあるかどうか",
    "index": "分割されたデータのインデックス",
    "sequence": "データの連番(分割されたものは同一)",
  }
  ```

+ 暗号文: 接続の確認  

  ```json
  {
    "type": "ping",
  }
  ```

+ 暗号文: 肯定応答(ACK), 正しく受信したことを通知する。  

  ```json
  {
    "type": "ok",
    "index": "受信した 分割されたデータのインデックス",
    "sequence": "受信した データの連番(分割されたものは同一)",
  }
  ```

+ 暗号文: 切断  

  ```json
  {
    "type": "close",
    "sequence": "最後に受信した データの連番(分割されたものは同一)",
  }
  ```

## 参考

+ <https://www.ipa.go.jp/security/crypto/guideline/ssl_crypt_config.html>  
+ <https://www.ipa.go.jp/security/crypto/guideline/gmcbt80000005ufv-att/ipa-cryptrec-gl-3001-3.1.0.pdf>  
+ <https://www.cryptrec.go.jp/list.html>  
+ <https://www.cryptrec.go.jp/list/cryptrec-ls-0003-2022r1.pdf>  
